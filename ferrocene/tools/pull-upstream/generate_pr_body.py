#!/usr/bin/env python3
# SPDX-License-Identifier: MIT OR Apache-2.0
# SPDX-FileCopyrightText: The Ferrocene Developers

# Helper script to generate the pull request body for a PR pulling the latest
# changes from upstream. It's automatically invoked by automation.py, and can
# be invoked manually if the pull is performed manually (on merge conflicts).

import subprocess
from dataclasses import dataclass
from typing import Optional
import sys


UPSTREAM_REPO = "rust-lang/rust"


def extract_pr_from_message(kind, message):
    """
    Parse commit messages generated by Homu, rust-lang/rust's merge bot.
    """
    parts = message.split(" ")
    if len(parts) < 4 or parts[0] != kind or parts[1] != "merge" or parts[2] != "of":
        return
    pr = parts[3]

    # Future-proof if upstream starts adding repo/name as a prefix
    # https://github.com/rust-lang/homu/pull/145
    if pr.startswith("#"):
        pr = f"{UPSTREAM_REPO}{pr}"
    return pr


def render_changes(origin, base_branch, new_branch):
    """
    Render the changes that happened in the upstream repository since the last
    automatic pull as a bullet list of merged pull requests. This also renders
    pull requests merged as part of a rollup.
    """

    # Ensure we have all the commits we need, otherwise the log command
    # below could fail.
    subprocess.run(["git", "fetch", origin], check=True)

    # Obtain commit hash, parent commit hashes and commit message from git
    changes = subprocess.run(
        [
            "git",
            "log",
            "--format=%H|%P|%s",
            "--reverse",
            f"{origin}/{base_branch}..{new_branch}",
            # Force git to consider the above string as a revision range
            # and not a path. Due to the structure of the revision range it
            # could end up being ambiguous.
            "--",
        ],
        check=True,
        text=True,
        stdout=subprocess.PIPE,
    ).stdout.strip()

    # Recreate the commit graph
    commits = {}
    last = None
    for line in changes.split("\n"):
        if not line:
            continue
        hash, parents, message = line.split("|", 2)
        parents = parents.split(" ")

        commit = Commit(hash, parents[0], message)
        if len(parents) > 1:
            commit.merge = parents[1]
        commits[hash] = commit
        last = hash

    # If no changes were detected just return nothing
    if last is None:
        return "**Nothing**"

    # Parse the commit graph and generate the list of changes
    changes = ""
    cursor = commits[last].merge
    while cursor in commits:
        commit = commits[cursor]
        cursor = commit.parent

        pr = extract_pr_from_message("Auto", commit.message)
        if pr is None:
            continue
        changes += f"* {pr}\n"

        if commit.merge in commits:
            rollup_cursor = commit.merge
            while rollup_cursor in commits:
                rollup_commit = commits[rollup_cursor]
                rollup_cursor = rollup_commit.parent

                rollup_pr = extract_pr_from_message("Rollup", rollup_commit.message)
                if rollup_pr is None:
                    break
                changes += f"  * {rollup_pr}\n"

    return changes


@dataclass
class Commit:
    hash: str
    parent: str
    message: str
    merge: Optional[str] = None


if __name__ == "__main__":
    if len(sys.argv) != 4:
        print(
            f"usage: {sys.argv[0]} <origin> <base-branch> <new-branch>", file=sys.stderr
        )
        exit(1)

    print(render_changes(sys.argv[1], sys.argv[2], sys.argv[3]))
