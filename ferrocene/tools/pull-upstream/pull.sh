#!/bin/bash
# SPDX-License-Identifier: MIT OR Apache-2.0
# SPDX-FileCopyrightText: The Ferrocene Developers

set -euo pipefail
IFS=$'\n\t'

UPSTREAM_REPO="https://github.com/rust-lang/rust"
TEMP_BRANCH="pull-upstream-temp--do-not-use-for-real-code"

# Print all files with the `ferrocene-avoid-pulling-from-upstream` attribute.
#
# `sort | uniq` is used because during merges files might show up multiple
# times if they have a conflict, and we don't want that.
excluded_files() {
    git ls-files \
        | git check-attr ferrocene-avoid-pulling-from-upstream --stdin \
        | grep ' set$' \
        | sed 's/:.*$//' \
        | sort \
        | uniq
}

if [[ $# -lt 1 ]] || [[ $# -gt 3 ]]; then
    echo "usage: $0 <upstream-branch> [base-branch] [upstream-commit]"
    exit 1
fi
upstream_branch="$1"
if [[ $# -ge 2 ]]; then
    current_branch="$2"
else
    current_branch="$(git branch --show-current)"
fi
if [[ $# -ge 3 ]]; then
    upstream_commit="$3"
else
    upstream_commit="FETCH_HEAD"  # Latest commit in the branch we pull.
fi

# Move to the root of the repository to avoid the script from misbehaving.
cd "$(git rev-parse --show-toplevel)"

# Safety check to avoid messing with uncommitted changes.
if ! git diff-index --quiet HEAD; then
    echo "pull-upstream: the current branch contains uncommitted changes!"
    echo "pull-upstream: make sure all changes are committed before running this script."
    exit 1
fi

# Make sure the temporary branch doesn't exist yet.
if git rev-parse --quiet --verify "${TEMP_BRANCH}" > /dev/null; then
    git branch -D "${TEMP_BRANCH}"
fi

git fetch "${UPSTREAM_REPO}" "${upstream_branch}"
git checkout -b "${TEMP_BRANCH}" "${upstream_commit}"

# Delete all the files excluded from the pull. Those files are marked with the
# `ferrocene-avoid-pulling-from-upstream` in `.gitattributes`.
git checkout "${current_branch}" -- .gitattributes
excluded_files | xargs git rm
git checkout FETCH_HEAD -- .gitattributes

git commit -F- <<EOF
remove excluded files from upstream

This commit is generated by \`ferrocene/tools/pull-upstream/pull.sh\`.
The list of excluded files is defined in \`.gitattributes\`.
EOF

# This will be configured by the GitHub Actions workflow dispatch.
case "${MERGE_STRATEGY-default}" in
    default)
        merge_flags=()
        ;;
    ours)
        merge_flags=("-X" "ours")
        ;;
    theirs)
        merge_flags=("-X" "theirs")
        ;;
    *)
        echo "unknown merge strategy: ${MERGE_STRATEGY}"
        exit 1
        ;;
esac

git checkout "${current_branch}"
if ! git merge "${merge_flags[@]}" "${TEMP_BRANCH}" --no-edit -m "pull new changes from upstream"; then
    # Merging failed, but the script might be able to resolve all the conflicts
    # on its own. This tries to resolve known conflicts and finish the merge.
    # If not all conflicts were resolved control is given back to the user.

    # Files excluded by the pull that are also present in Ferrocene (for example
    # a different README) will cause merge conflicts. In those cases we always
    # want to preserve Ferrocene's version, so we can solve ht e conflict
    # automatically.
    for file in $(excluded_files); do
        echo "pull-upstream: automatically resolving conflict for ${file}..."
        git show "${current_branch}:${file}" > "${file}"
        git add "${file}"
        echo "pull-upstream: automatically resolved conflict for ${file}"
    done

    # Git attempts to merge submodule bumps correctly, but it only works if one
    # of the two branches has the same submodule commit as the merge base. If
    # that's not true (for example if we get behind with pulls), git refuses to
    # merge automatically and outputs this fairly confusing diff:
    #
    # - Subproject commit 03bc66b55c290324bd46eb22e369c8fae1908f91
    #  -Subproject commit 694a579566a9a1482b20aff8a68f0e4edd99bd28
    # ++Subproject commit 0000000000000000000000000000000000000000
    #
    # To solve that, when a submodule gets in an unmerged state, the confict is
    # fixed automatically by resetting the submodule to upstream's commit.
    all_submodules="$(git config --file .gitmodules --get-regexp 'submodule\..+\.path' | awk '{print($2)}')"
    for changed_file in $(git status --porcelain=v1 | sed -n 's/^UU //p'); do
        if grep -q "^${changed_file}$" <(echo "${all_submodules}"); then
            git reset "${upstream_commit}" -- "${changed_file}"
            echo "pull-upstream: automatically resolved conflict for submodule ${changed_file}"
        fi
    done

    # There could be conflicts between our Cargo.lock and upstream's, as we
    # have our own crates with our own dependencies in the workspace.
    # Automatically resolve any conflict involving Cargo.lock to prefer our own
    # copy of the lockfile rather than upstream's.
    if git status --porcelain=v1 | grep "^UU Cargo.lock$" --quiet; then
        echo "pull-upstream: automatically resolving conflict for Cargo.lock..."
        git show "${current_branch}:Cargo.lock" > Cargo.lock

        # Invoking any Cargo command touching the lockfile will cause the
        # lockfile to be updated. "cargo metadata" is one of the fastest ones.
        # The bootstrap flag is needed as the workspace uses unstable features.
        RUSTC_BOOTSTRAP=1 cargo metadata --format-version=1 >/dev/null

        git add Cargo.lock
        echo "pull-upstream: automatically resolved conflict for Cargo.lock"
    fi

    if git diff --diff-filter=U --quiet; then
        # Setting the editor to `true` prevents the actual editor from being open,
        # as in this case we don't want to change the default message.
        GIT_EDITOR="$(which true)" git merge --continue
    else
        echo
        echo "pull-upstream: there are unresolved merge conflicts"
        echo "pull-upstream: resolve the conflicts manually and then run \`git merge --continue\`."
        exit 1
    fi
fi

# If there were no changes made since the last pull (aka when the diff from the
# previous commit and the pull is empty) remove the empty merge commit and
# exit with a special code to let the automation know it shouldn't open PRs.
if git diff --quiet HEAD^..HEAD; then
    echo "pull-upstream: no changes to pull"
    git reset HEAD^
    exit 42
fi

git branch -D "${TEMP_BRANCH}"

echo
echo "You can generate the PR body manually by running:"
echo
echo "    ferrocene/tools/pull-upstream/generate_pr_body.py origin <base-branch> <current-branch>"
echo
